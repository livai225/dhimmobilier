// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://hmchlpzrhkneqhcjpwvk.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhtY2hscHpyaGtuZXFoY2pwd3ZrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQxNDkwOTQsImV4cCI6MjA2OTcyNTA5NH0.HiOc3Zcvgh2_I538C0CIBKNgGPbFiAWNyWBRlNuhxQg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// --- Global Realtime subscription with React Query invalidation ---
let invalidationTimeout: number | undefined;
let queryClient: any = null;
let lastEventTime = 0;
const MIN_EVENT_INTERVAL = 300; // Minimum ms between events to prevent spam

// Initialize queryClient when available
export const setQueryClient = (client: any) => {
  queryClient = client;
  console.log('[Realtime] QueryClient configuré pour les invalidations intelligentes');
};

function scheduleDataInvalidation(tableName: string, eventType: string) {
  if (typeof window === 'undefined') return;
  
  // Throttle events to prevent spam
  const now = Date.now();
  if (now - lastEventTime < MIN_EVENT_INTERVAL) {
    console.log(`[Realtime] Événement throttlé: ${eventType} sur ${tableName}`);
    return;
  }
  lastEventTime = now;
  
  // Clear previous timeout to debounce multiple rapid changes
  if (invalidationTimeout) {
    window.clearTimeout(invalidationTimeout);
  }
  
  invalidationTimeout = window.setTimeout(() => {
    invalidationTimeout = undefined;
    console.log(`[Realtime] Invalidation des requêtes pour ${tableName} (${eventType}) à ${new Date().toLocaleTimeString()}`);
    
    if (queryClient) {
      // Invalidate specific queries based on table name
      const tableQueries = getQueriesForTable(tableName);
      tableQueries.forEach(queryKey => {
        console.log(`[Realtime] Invalidation de la requête:`, queryKey);
        queryClient.invalidateQueries({ queryKey });
      });
    } else {
      console.warn('[Realtime] QueryClient non disponible - invalidation ignorée');
    }
  }, 400); // Reduced timeout for better responsiveness
}

function getQueriesForTable(tableName: string): string[][] {
  // Map tables to their related query keys
  const queryMap: Record<string, string[][]> = {
    clients: [['clients']],
    proprietes: [['properties'], ['dashboard-stats']],
    locations: [['locations'], ['dashboard-stats']],
    souscriptions: [['souscriptions'], ['dashboard-stats']],
    paiements_locations: [['receipts'], ['dashboard-stats']],
    paiements_souscriptions: [['receipts'], ['dashboard-stats']],
    paiements_cautions: [['receipts'], ['dashboard-stats']],
    paiements_droit_terre: [['receipts'], ['dashboard-stats']],
    paiements_factures: [['receipts'], ['dashboard-stats']],
    versements_agents: [['receipts'], ['dashboard-stats']],
    factures_fournisseurs: [['factures'], ['dashboard-stats']],
    fournisseurs: [['fournisseurs']],
    agents: [['agents']],
    cash_transactions: [['dashboard-stats'], ['caisse']],
    echeances_droit_terre: [['dashboard-stats']],
  };
  
  return queryMap[tableName] || [['dashboard-stats']]; // Default fallback
}

// Improved error handling and filtering
try {
  const channel = supabase
    .channel('realtime-public-all')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public' },
      (payload: any) => {
        const tableName = payload?.table;
        const eventType = payload?.eventType;
        
        // Enhanced logging for debugging
        console.log(
          `[Realtime] ${eventType || 'event'} sur ${payload?.schema || 'public'}.${tableName || '?'}`,
          { 
            table: tableName,
            event: eventType,
            timestamp: new Date().toISOString(),
            recordId: payload?.new?.id || payload?.old?.id
          }
        );

        // Filter out non-essential events to reduce noise
        if (!tableName || !eventType) {
          console.log('[Realtime] Événement ignoré - informations manquantes');
          return;
        }

        // Filter out system tables and irrelevant changes
        const ignoredTables = ['pg_stat', 'information_schema'];
        if (ignoredTables.some(ignored => tableName.startsWith(ignored))) {
          console.log(`[Realtime] Table système ignorée: ${tableName}`);
          return;
        }

        // Dispatch custom event for fine-grained subscriptions
        if (typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('supabase:realtime-change', { 
            detail: { 
              ...payload, 
              processedAt: Date.now(),
              table: tableName,
              event: eventType
            }
          }));
        }

        // Invalidate data instead of reloading the page
        scheduleDataInvalidation(tableName, eventType);
      }
    )
    .subscribe((status) => {
      console.log('[Realtime] Canal statut:', status, 'à', new Date().toISOString());
      
      if (status === 'SUBSCRIBED') {
        console.log('[Realtime] ✅ Connexion Realtime établie avec succès');
      } else if (status === 'CHANNEL_ERROR') {
        console.error('[Realtime] ❌ Erreur de connexion Realtime');
      } else if (status === 'TIMED_OUT') {
        console.warn('[Realtime] ⏰ Timeout de connexion Realtime');
      }
    });
} catch (e) {
  console.warn('[Realtime] Impossible d\'initialiser la souscription Realtime', e);
}